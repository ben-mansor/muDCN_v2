#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <getopt.h>
#include <bpf/bpf.h>
#include <bpf/libbpf.h>
#include <net/if.h>
#include <linux/if_link.h>
#include <signal.h>
#include <unistd.h>
#include <sys/resource.h>

#include "../include/ndn_maps.h"

// Will be generated by bpftool gen skeleton
#include "../include/ndn_parser.skel.h"

static volatile int running = 1;
static int ifindex = 0;
static struct bpf_object *obj = NULL;
static int xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST | XDP_FLAGS_DRV_MODE;

// Handle Ctrl+C gracefully
static void int_exit(int sig)
{
    running = 0;
}

// Helper function to increase rlimit for locked memory (required for eBPF maps)
static void bump_memlock_rlimit(void)
{
    struct rlimit rlim_new = {
        .rlim_cur = RLIM_INFINITY,
        .rlim_max = RLIM_INFINITY,
    };

    if (setrlimit(RLIMIT_MEMLOCK, &rlim_new)) {
        fprintf(stderr, "Warning: Failed to increase RLIMIT_MEMLOCK limit!\n");
        perror("setrlimit");
    }
}

// Print statistics from the stats_map
static void print_stats(int map_fd)
{
    struct ndn_stats stats = {0};
    uint32_t key = 0;

    if (bpf_map_lookup_elem(map_fd, &key, &stats) != 0) {
        fprintf(stderr, "Failed to read statistics\n");
        return;
    }

    printf("\nNDN XDP Statistics:\n");
    printf("  Interests received: %llu\n", stats.interests_received);
    printf("  Interests forwarded: %llu\n", stats.interests_forwarded);
    printf("  Data received: %llu\n", stats.data_received);
    printf("  Data forwarded: %llu\n", stats.data_forwarded);
    printf("  Cache hits: %llu\n", stats.cache_hits);
    printf("  Cache misses: %llu\n", stats.cache_misses);
    printf("\n");
}

// Configure interface forwarding
static int setup_redirect(int redirect_map_fd, int from_ifindex, int to_ifindex)
{
    if (bpf_map_update_elem(redirect_map_fd, &from_ifindex, &to_ifindex, BPF_ANY)) {
        fprintf(stderr, "Failed to update redirect map: %s\n", strerror(errno));
        return -1;
    }
    printf("Set up forwarding from interface %d to interface %d\n", from_ifindex, to_ifindex);
    return 0;
}

static void usage(const char *prog)
{
    printf("Usage: %s [OPTIONS]\n"
           "Options:\n"
           "  -i, --interface=<ifname>   Name of interface to attach XDP program\n"
           "  -r, --redirect=<ifname>    Name of interface to redirect traffic to\n"
           "  -s, --skb-mode             Install XDP program in SKB (generic) mode\n"
           "  -h, --help                 Show this help\n",
           prog);
}

int main(int argc, char **argv)
{
    struct ndn_parser_xdp_bpf *skel;
    char ifname[IF_NAMESIZE] = "";
    char redirect_ifname[IF_NAMESIZE] = "";
    int redirect_ifindex = 0;
    int stats_map_fd, redirect_map_fd;
    int err;

    // Parse command line arguments
    struct option long_options[] = {
        {"interface", required_argument, NULL, 'i'},
        {"redirect", required_argument, NULL, 'r'},
        {"skb-mode", no_argument, NULL, 's'},
        {"help", no_argument, NULL, 'h'},
        {NULL, 0, NULL, 0}
    };

    int opt;
    while ((opt = getopt_long(argc, argv, "i:r:sh", long_options, NULL)) != -1) {
        switch (opt) {
        case 'i':
            strncpy(ifname, optarg, IF_NAMESIZE - 1);
            break;
        case 'r':
            strncpy(redirect_ifname, optarg, IF_NAMESIZE - 1);
            break;
        case 's':
            xdp_flags &= ~XDP_FLAGS_DRV_MODE;
            xdp_flags |= XDP_FLAGS_SKB_MODE;
            break;
        case 'h':
        default:
            usage(argv[0]);
            return opt == 'h' ? EXIT_SUCCESS : EXIT_FAILURE;
        }
    }

    // Check for required interface name
    if (ifname[0] == '\0') {
        fprintf(stderr, "Error: interface name is required\n");
        usage(argv[0]);
        return EXIT_FAILURE;
    }

    // Get interface index
    ifindex = if_nametoindex(ifname);
    if (!ifindex) {
        fprintf(stderr, "Error: interface '%s' not found\n", ifname);
        return EXIT_FAILURE;
    }

    // Get redirect interface index if specified
    if (redirect_ifname[0] != '\0') {
        redirect_ifindex = if_nametoindex(redirect_ifname);
        if (!redirect_ifindex) {
            fprintf(stderr, "Error: redirect interface '%s' not found\n", redirect_ifname);
            return EXIT_FAILURE;
        }
    }

    // Increase rlimit for locked memory (required for eBPF maps)
    bump_memlock_rlimit();

    // Set up signal handling for Ctrl+C
    signal(SIGINT, int_exit);
    signal(SIGTERM, int_exit);

    // Open BPF object
    skel = ndn_parser_xdp_bpf__open();
    if (!skel) {
        fprintf(stderr, "Failed to open BPF skeleton\n");
        return EXIT_FAILURE;
    }

    // Load & verify BPF programs
    err = ndn_parser_xdp_bpf__load(skel);
    if (err) {
        fprintf(stderr, "Failed to load and verify BPF programs: %s\n", strerror(errno));
        goto cleanup;
    }

    // Attach XDP program to interface
    err = bpf_set_link_xdp_fd(ifindex, bpf_program__fd(skel->progs.ndn_parser_xdp_func), xdp_flags);
    if (err) {
        fprintf(stderr, "Failed to attach XDP program to interface %s: %s\n", 
                ifname, strerror(-err));
        goto cleanup;
    }

    printf("Successfully attached XDP program to interface %s (ifindex %d)\n", ifname, ifindex);

    // Get map file descriptors
    stats_map_fd = bpf_map__fd(skel->maps.stats_map);
    redirect_map_fd = bpf_map__fd(skel->maps.redirect_map);
    
    // Initialize statistics
    struct ndn_stats stats = {0};
    uint32_t key = 0;
    bpf_map_update_elem(stats_map_fd, &key, &stats, BPF_ANY);

    // Set up redirect if specified
    if (redirect_ifindex) {
        if (setup_redirect(redirect_map_fd, ifindex, redirect_ifindex) != 0) {
            goto cleanup;
        }
    }

    printf("NDN parser XDP program loaded and running.\n");
    printf("Press Ctrl+C to stop and view statistics.\n");

    // Main loop - print stats every second
    while (running) {
        sleep(1);
        print_stats(stats_map_fd);
    }

cleanup:
    // Clean up: detach XDP program and free resources
    bpf_set_link_xdp_fd(ifindex, -1, xdp_flags);
    ndn_parser_xdp_bpf__destroy(skel);
    return err != 0 ? EXIT_FAILURE : EXIT_SUCCESS;
}
