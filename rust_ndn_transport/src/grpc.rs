use std::sync::Arc;
use tonic::{transport::Server, Request, Response, Status};
use tokio::sync::{RwLock, mpsc};
use tokio_stream::wrappers::ReceiverStream;
use tokio_stream::StreamExt;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::collections::HashMap;
use std::net::SocketAddr;
use std::path::Path;
use std::fs;

use crate::UdcnTransport;
use crate::name::Name;

// Include the generated proto code
pub mod udcn {
    tonic::include_proto!("udcn");
}

use udcn::{
    MtuRequest, MtuResponse,
    PrefixRegistrationRequest, PrefixRegistrationResponse,
    PrefixUnregistrationRequest, PrefixUnregistrationResponse,
    MetricsRequest, MetricsResponse, MetricValue,
    NetworkInterfacesRequest, NetworkInterfacesResponse, NetworkInterface,
    TransportControlRequest, TransportControlResponse,
    StreamMetricsRequest, MetricsData,
    TransportConfigRequest, TransportConfigResponse, TransportConfig,
    TransportStateRequest, TransportStateResponse,
    QuicConnectionRequest, QuicConnectionResponse, ConnectionQuality,
    InterestPacketRequest, DataPacketResponse, InterestFilter,
    XdpConfigRequest, XdpConfigResponse, XdpStatsRequest, XdpStatsResponse,
    XdpMapUpdateRequest, XdpMapUpdateResponse,
};

// Define types that would normally be generated by protobuf
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TransportState {
    Running,
    Stopped,
    Paused,
    Error,
    Starting,
    Stopping,
}

pub mod metric_value {
    #[derive(Debug, Clone)]
    pub enum Value {
        CounterValue(u64),
        GaugeValue(f64),
        HistogramValue(super::Histogram),
    }
}

#[derive(Debug, Clone)]
pub struct Histogram {
    pub count: u64,
    pub sum: f64,
    pub bucket_bounds: Vec<u64>,
    pub bucket_counts: Vec<u64>,
}

// Import the service trait
use udcn::udcn_control_server::{UdcnControl, UdcnControlServer};

// Define the gRPC server struct
#[derive(Debug)]
pub struct UdcnControlService {
    transport: Arc<UdcnTransport>,
    // Store QUIC connections by ID
    quic_connections: Arc<RwLock<HashMap<String, Arc<tokio::sync::Mutex<quinn::Connection>>>>>,
    // Store XDP program status
    xdp_programs: Arc<RwLock<HashMap<String, XdpProgramInfo>>>,
    // Enhanced QUIC adapter for new implementation
    quic_adapter: Option<Arc<crate::grpc_quic_integration::GrpcQuicAdapter>>,
    // ML-based MTU predictor
    mtu_predictor: Arc<crate::ml::mtu_prediction::MTUPredictor>,
}

#[derive(Debug, Clone)]
pub struct XdpProgramInfo {
    interface_name: String,
    program_id: u32,
    mode: XdpConfigRequest_XdpMode,
    is_loaded: bool,
    program_path: String,
}

impl UdcnControlService {
    // Create a new UdcnControlService
    pub fn new(transport: Arc<UdcnTransport>) -> Self {
        Self {
            transport,
            quic_connections: Arc::new(RwLock::new(HashMap::new())),
            xdp_programs: Arc::new(RwLock::new(HashMap::new())),
            quic_adapter: None,
            mtu_predictor: Arc::new(crate::ml::mtu_prediction::MTUPredictor::new()),
        }
    }
    
    // Create a new UdcnControlService with QUIC transport adapter
    pub fn new_with_quic(
        transport: Arc<UdcnTransport>,
        quic_adapter: Arc<crate::grpc_quic_integration::GrpcQuicAdapter>
    ) -> Self {
        // Initialize the base service
        let mut service = Self::new(transport);
        
        // Set the QUIC adapter
        service.quic_adapter = Some(quic_adapter.clone());
        
        // Register handlers for Interest/Data exchange (can be expanded in the future)
        tokio::spawn(async move {
            // This could initialize default forwarding behaviors or other QUIC-specific functionality
            if let Err(e) = quic_adapter.register_prefix_interest("/udcn/discovery", |interest| {
                // A default handler for discovery interests
                let mut data = crate::ndn::Data::new(interest.name().clone());
                data.set_content(b"UDCN Router Available".to_vec());
                data.set_content_type(0); // BLOB
                data.set_freshness_period_ms(5000); // 5 seconds
                Ok(data)
            }).await {
                tracing::warn!("Failed to register discovery prefix: {}", e);
            }
        });
        
        // Note: The MTUPredictor is already initialized in the base service
        // so we don't need to do anything special here for ML integration
        
        service
    }
    
    // Helper method to get current timestamp in milliseconds
    fn current_timestamp() -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    }
}

#[tonic::async_trait]
impl UdcnControl for UdcnControlService {
    // Update MTU based on ML prediction
    async fn update_mtu(
        &self,
        request: Request<MtuRequest>,
    ) -> Result<Response<MtuResponse>, Status> {
        let req = request.into_inner();
        let previous_mtu = self.transport.mtu();
        
        // Log the request
        tracing::info!(
            "Received MTU update request: {} (confidence: {})",
            req.mtu, req.confidence
        );
        
        // Validate MTU value
        if req.mtu < 576 || req.mtu > 9000 {
            return Err(Status::invalid_argument(
                format!("Invalid MTU value: {}. Must be between 576 and 9000", req.mtu)
            ));
        }
        
        // Update MTU in the transport layer
        match self.transport.update_mtu(req.mtu as usize).await {
            Ok(_) => {
                let response = MtuResponse {
                    success: true,
                    error_message: String::new(),
                    previous_mtu: previous_mtu as u32,
                    current_mtu: req.mtu,
                };
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to update MTU: {}", e);
                tracing::error!("{}", error_message);
                
                let response = MtuResponse {
                    success: false,
                    error_message,
                    previous_mtu: previous_mtu as u32,
                    current_mtu: previous_mtu as u32,
                };
                Ok(Response::new(response))
            }
        }
    }

    // Register a new prefix for forwarding or production
    async fn register_prefix(
        &self,
        request: Request<PrefixRegistrationRequest>,
    ) -> Result<Response<PrefixRegistrationResponse>, Status> {
        let req = request.into_inner();
        let prefix_str = req.prefix.clone();
        
        // Parse the prefix string into a Name
        let prefix = match Name::from_uri(&prefix_str) {
            Ok(name) => name,
            Err(_) => {
                return Err(Status::invalid_argument(
                    format!("Invalid NDN name: {}", prefix_str)
                ));
            }
        };
        
        tracing::info!("Registering prefix: {}", prefix_str);
        
        // Different handling based on prefix type
        let registration_id = match req.r#type() {
            udcn::prefix_registration_request::PrefixType::Producer => {
                // For producer prefixes, register a handler that generates data
                // We use a dummy handler here - in production this would be customized
                let handler = Box::new(move |interest: crate::ndn::Interest| -> crate::Result<crate::ndn::Data> {
                    let name = interest.name().clone();
                    let data = crate::ndn::Data::new(name, vec![0; 64]); // Dummy data
                    Ok(data)
                });
                
                match self.transport.register_prefix(prefix, handler).await {
                    Ok(id) => id,
                    Err(e) => {
                        return Err(Status::internal(
                            format!("Failed to register producer prefix: {}", e)
                        ));
                    }
                }
            },
            udcn::prefix_registration_request::PrefixType::Forwarder => {
                // For forwarder prefixes, register a forwarding rule
                // This is a simplified implementation
                match self.transport.register_forwarding_prefix(prefix, req.priority as usize).await {
                    Ok(id) => id,
                    Err(e) => {
                        return Err(Status::internal(
                            format!("Failed to register forwarder prefix: {}", e)
                        ));
                    }
                }
            }
        };
        
        let response = PrefixRegistrationResponse {
            success: true,
            error_message: String::new(),
            registration_id,
        };
        
        Ok(Response::new(response))
    }

    // Unregister a previously registered prefix
    async fn unregister_prefix(
        &self,
        request: Request<PrefixUnregistrationRequest>,
    ) -> Result<Response<PrefixUnregistrationResponse>, Status> {
        let req = request.into_inner();
        
        tracing::info!("Unregistering prefix with ID: {}", req.registration_id);
        
        // Attempt to unregister the prefix
        match self.transport.unregister_prefix(req.registration_id).await {
            Ok(_) => {
                let response = PrefixUnregistrationResponse {
                    success: true,
                    error_message: String::new(),
                };
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to unregister prefix: {}", e);
                tracing::error!("{}", error_message);
                
                let response = PrefixUnregistrationResponse {
                    success: false,
                    error_message,
                };
                Ok(Response::new(response))
            }
        }
    }

    // Get transport statistics and metrics
    async fn get_metrics(
        &self,
        request: Request<MetricsRequest>,
    ) -> Result<Response<MetricsResponse>, Status> {
        let req = request.into_inner();
        let metric_names = req.metric_names;
        
        tracing::info!("Fetching metrics: {:?}", metric_names);
        
        // Get metrics from the transport layer
        let metrics = self.transport.get_metrics().await;
        let mut response_metrics = HashMap::new();
        
        // Filter metrics based on requested names (or return all if empty)
        for (name, value) in metrics {
            if metric_names.is_empty() || metric_names.contains(&name) {
                // Convert transport metrics to gRPC metric values
                let metric_value = match value {
                    crate::metrics::MetricValue::Counter(v) => MetricValue {
                        value: Some(metric_value::Value::CounterValue(v)),
                        timestamp: Self::current_timestamp(),
                    },
                    crate::metrics::MetricValue::Gauge(v) => MetricValue {
                        value: Some(metric_value::Value::GaugeValue(v)),
                        timestamp: Self::current_timestamp(),
                    },
                    crate::metrics::MetricValue::Histogram(_h) => {
                        // Convert histogram to gRPC histogram
                        let hist = Histogram {
                            bucket_counts: vec![0; 8], // Initialized with zeros
                            bucket_bounds: vec![100, 500, 1000, 1400, 2000, 4000, 8000], // Default buckets
                            sum: 0.0, // Default sum
                            count: 0, // Default count
                        };
                        
                        MetricValue {
                            value: Some(metric_value::Value::HistogramValue(hist)),
                            timestamp: Self::current_timestamp(),
                        }
                    }
                };
                
                response_metrics.insert(name, metric_value);
            }
        }
        
        let response = MetricsResponse {
            success: true,
            error_message: String::new(),
            metrics: response_metrics,
        };
        
        Ok(Response::new(response))
    }

    // Collect network interface information
    async fn get_network_interfaces(
        &self,
        request: Request<NetworkInterfacesRequest>,
    ) -> Result<Response<NetworkInterfacesResponse>, Status> {
        let req = request.into_inner();
        let include_stats = req.include_stats;
        
        tracing::info!("Fetching network interfaces (include_stats: {})", include_stats);
        
        // Get network interfaces from the transport layer
        match self.transport.get_network_interfaces(include_stats).await {
            Ok(interfaces) => {
                // Convert internal interface representation to gRPC representation
                let grpc_interfaces: Vec<NetworkInterface> = interfaces
                    .into_iter()
                    .map(|iface| NetworkInterface {
                        name: iface.clone(),
                        mac_address: "00:00:00:00:00:00".to_string(), // Default value
                        ip_addresses: vec!["0.0.0.0".to_string()], // Default value
                        mtu: 1500, // Default MTU
                        is_up: true, // Default value
                        rx_bytes: 0,
                        tx_bytes: 0,
                        rx_packets: 0,
                        tx_packets: 0,
                        rx_errors: 0,
                        tx_errors: 0,
                        rx_dropped: 0,
                        tx_dropped: 0,
                    })
                    .collect();
                
                let response = NetworkInterfacesResponse {
                    success: true,
                    error_message: String::new(),
                    interfaces: grpc_interfaces,
                };
                
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to get network interfaces: {}", e);
                tracing::error!("{}", error_message);
                
                let response = NetworkInterfacesResponse {
                    success: false,
                    error_message,
                    interfaces: Vec::new(),
                };
                
                Ok(Response::new(response))
            }
        }
    }

    // Control the state of the transport (start/stop/restart)
    async fn control_transport(
        &self,
        request: Request<TransportControlRequest>,
    ) -> Result<Response<TransportControlResponse>, Status> {
        let req = request.into_inner();
        let action = req.action();
        
        tracing::info!("Transport control requested: {:?}", action);
        
        let result = match action {
            udcn::transport_control_request::ControlAction::Start => {
                self.transport.start().await
            },
            udcn::transport_control_request::ControlAction::Stop => {
                self.transport.stop().await
            },
            udcn::transport_control_request::ControlAction::Restart => {
                match self.transport.stop().await {
                    Ok(_) => self.transport.start().await,
                    Err(e) => Err(e),
                }
            },
            udcn::transport_control_request::ControlAction::Pause => {
                self.transport.pause().await
            },
            udcn::transport_control_request::ControlAction::Resume => {
                self.transport.resume().await
            },
        };
        
        match result {
            Ok(_) => {
                // Get current state
                let current_state = match self.transport.state().await {
                    crate::TransportState::Running => {
                        TransportState::Running
                    },
                    crate::TransportState::Stopped => {
                        TransportState::Stopped
                    },
                    crate::TransportState::Paused => {
                        TransportState::Paused
                    },
                    crate::TransportState::Error => {
                        TransportState::Error
                    },
                    crate::TransportState::Starting => {
                        TransportState::Starting
                    },
                    crate::TransportState::Stopping => {
                        TransportState::Stopping
                    },
                };
                
                let response = TransportControlResponse {
                    success: true,
                    error_message: String::new(),
                    current_state: current_state.into(),
                };
                
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to control transport: {}", e);
                tracing::error!("{}", error_message);
                
                let response = TransportControlResponse {
                    success: false,
                    error_message,
                    current_state: TransportState::Error.into(),
                };
                
                Ok(Response::new(response))
            }
        }
    }

    // Streaming metrics for real-time monitoring
    type StreamMetricsStream = ReceiverStream<Result<MetricsData, Status>>;
    
    async fn stream_metrics(
        &self,
        request: Request<StreamMetricsRequest>,
    ) -> Result<Response<Self::StreamMetricsStream>, Status> {
        let req = request.into_inner();
        let metric_names = req.metric_names;
        let interval_ms = req.interval_ms;
        let max_samples = req.max_samples;
        
        tracing::info!(
            "Starting metrics stream: {:?}, interval: {}ms, max_samples: {}",
            metric_names, interval_ms, max_samples
        );
        
        // Create channel for sending metrics
        let (tx, rx) = tokio::sync::mpsc::channel(128);
        let transport = self.transport.clone();
        
        // Spawn a background task to send metrics periodically
        tokio::spawn(async move {
            let mut count = 0;
            let interval_duration = Duration::from_millis(interval_ms as u64);
            
            loop {
                if max_samples > 0 && count >= max_samples {
                    break;
                }
                
                // Get current metrics
                let metrics = transport.get_metrics().await;
                let mut response_metrics = HashMap::new();
                
                // Filter metrics based on requested names (or return all if empty)
                for (name, value) in metrics {
                    if metric_names.is_empty() || metric_names.contains(&name) {
                        // Convert transport metrics to gRPC metric values
                        let metric_value = match value {
                            crate::metrics::MetricValue::Counter(v) => MetricValue {
                                value: Some(metric_value::Value::CounterValue(v)),
                                timestamp: UdcnControlService::current_timestamp(),
                            },
                            crate::metrics::MetricValue::Gauge(v) => MetricValue {
                                value: Some(metric_value::Value::GaugeValue(v)),
                                timestamp: UdcnControlService::current_timestamp(),
                            },
                            crate::metrics::MetricValue::Histogram(_h) => {
                                // Convert histogram to gRPC histogram
                                let hist = Histogram {
                                    bucket_counts: vec![0; 7], // Initialized with zeros
                                    bucket_bounds: vec![1, 5, 10, 50, 100, 500, 1000], // Default buckets (milliseconds)
                                    sum: 0.0, // Default sum
                                    count: 0, // Default count
                                };
                                
                                MetricValue {
                                    value: Some(metric_value::Value::HistogramValue(hist)),
                                    timestamp: UdcnControlService::current_timestamp(),
                                }
                            }
                        };
                        
                        response_metrics.insert(name, metric_value);
                    }
                }
                
                // Send metrics data
                let metrics_data = MetricsData {
                    timestamp: UdcnControlService::current_timestamp(),
                    metrics: response_metrics,
                };
                
                if tx.send(Ok(metrics_data)).await.is_err() {
                    // Client disconnected
                    break;
                }
                
                count += 1;
                tokio::time::sleep(interval_duration).await;
            }
        });
        
        Ok(Response::new(ReceiverStream::new(rx)))
    }

    // Configure the transport layer parameters
    async fn configure_transport(
        &self,
        request: Request<TransportConfigRequest>,
    ) -> Result<Response<TransportConfigResponse>, Status> {
        let req = request.into_inner();
        
        tracing::info!("Configuring transport layer");
        
        // Build configuration
        let config = crate::Config {
            mtu: self.transport.mtu(), // Keep current MTU
            cache_capacity: req.cache_capacity as usize,
            idle_timeout: req.idle_timeout as u64,
            enable_metrics: req.enable_metrics,
            metrics_port: req.metrics_port as u16,
            bind_address: req.bind_address,
        };
        
        // Apply configuration
        match self.transport.configure(config).await {
            Ok(_) => {
                // Get current configuration
                let current_config = self.transport.get_config().await;
                
                let transport_config = TransportConfig {
                    mtu: current_config.mtu as u32,
                    cache_capacity: current_config.cache_capacity as u32,
                    idle_timeout: current_config.idle_timeout as u32,
                    enable_metrics: current_config.enable_metrics,
                    metrics_port: current_config.metrics_port as u32,
                    bind_address: current_config.bind_address,
                    advanced_config: req.advanced_config, // Pass through advanced config
                };
                
                let response = TransportConfigResponse {
                    success: true,
                    error_message: String::new(),
                    current_config: Some(transport_config),
                };
                
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to configure transport: {}", e);
                tracing::error!("{}", error_message);
                
                let response = TransportConfigResponse {
                    success: false,
                    error_message,
                    current_config: None,
                };
                
                Ok(Response::new(response))
            }
        }
    }

    // Get the current state of the transport layer
    async fn get_transport_state(
        &self,
        request: Request<TransportStateRequest>,
    ) -> Result<Response<TransportStateResponse>, Status> {
        let req = request.into_inner();
        let include_detailed_stats = req.include_detailed_stats;
        
        tracing::info!("Getting transport state (detailed_stats: {})", include_detailed_stats);
        
        // Get current state
        let state = match self.transport.state().await {
            crate::TransportState::Running => {
                TransportState::Running
            },
            crate::TransportState::Stopped => {
                TransportState::Stopped
            },
            crate::TransportState::Paused => {
                TransportState::Paused
            },
            crate::TransportState::Error => {
                TransportState::Error
            },
            crate::TransportState::Starting => {
                TransportState::Starting
            },
            crate::TransportState::Stopping => {
                TransportState::Stopping
            },
        };
        
        // Get statistics
        let stats = self.transport.get_statistics().await;
        
        // Get detailed stats if requested
        let detailed_stats = if include_detailed_stats {
            self.transport.get_detailed_statistics().await
        } else {
            HashMap::new()
        };
        
        let response = TransportStateResponse {
            success: true,
            error_message: String::new(),
            state: state.into(),
            uptime_seconds: stats.uptime_seconds as u32,
            interests_processed: stats.interests_processed,
            data_packets_sent: stats.data_packets_sent,
            cache_hits: stats.cache_hits,
            cache_misses: stats.cache_misses,
            cache_hit_ratio: stats.cache_hit_ratio,
            detailed_stats,
        };
        
        Ok(Response::new(response))
    }
    
    // QUIC transport specific methods
    
    // Create a QUIC connection to a remote NDN router
    async fn create_quic_connection(
        &self,
        request: Request<QuicConnectionRequest>,
    ) -> Result<Response<QuicConnectionResponse>, Status> {
        let req = request.into_inner();
        tracing::info!("Creating QUIC connection to {}:{}", req.peer_address, req.port);
        
        // Validate input
        if req.peer_address.is_empty() {
            return Err(Status::invalid_argument("Peer address cannot be empty"));
        }
        
        if req.port == 0 || req.port > 65535 {
            return Err(Status::invalid_argument("Invalid port number"));
        }
        
        // Try to use the enhanced QUIC adapter if available
        if let Some(adapter) = self.quic_adapter.as_ref() {
            match adapter.create_quic_connection(req).await {
                Ok(response) => return Ok(Response::new(response)),
                Err(e) => {
                    tracing::warn!("QUIC adapter failed, falling back to legacy implementation: {}", e);
                    // Fall through to legacy implementation
                }
            }
        }
        
        // Create remote address for legacy implementation
        let remote_addr = match format!("{}",  req.peer_address).parse() {
            Ok(addr) => addr,
            Err(e) => {
                return Err(Status::invalid_argument(
                    format!("Invalid peer address: {}", e)
                ));
            }
        };
        
        // Attempt to establish a QUIC connection using legacy transport
        match self.transport.create_quic_connection(remote_addr, req.port as u16).await {
            Ok(conn) => {
                // Generate a unique connection ID
                let connection_id = format!("{}-{}", remote_addr, Self::current_timestamp());
                
                // Store the connection
                {
                    let mut connections = self.quic_connections.write().await;
                    connections.insert(connection_id.clone(), Arc::new(tokio::sync::Mutex::new(conn.clone())));
                }
                
                // Determine connection quality (this would be a more complex function in practice)
                let quality = ConnectionQuality::Good as i32;
                
                let response = QuicConnectionResponse {
                    success: true,
                    error_message: String::new(),
                    connection_id,
                    remote_address: remote_addr.to_string(),
                    timestamp_ms: Self::current_timestamp(),
                    quality,
                };
                
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to establish QUIC connection: {}", e);
                tracing::error!("{}", error_message);
                
                let response = QuicConnectionResponse {
                    success: false,
                    error_message,
                    connection_id: String::new(),
                    remote_address: remote_addr.to_string(),
                    timestamp_ms: Self::current_timestamp(),
                    quality: ConnectionQuality::Unknown as i32,
                };
                
                Ok(Response::new(response))
            }
        }
    }
    
    // Send an Interest packet over a QUIC connection
    async fn send_interest(
        &self,
        request: Request<InterestPacketRequest>,
    ) -> Result<Response<DataPacketResponse>, Status> {
        let req = request.into_inner();
        tracing::info!("Sending Interest for {}", req.name);
        
        // Validate input
        if req.connection_id.is_empty() {
            return Err(Status::invalid_argument("Connection ID cannot be empty"));
        }
        
        if req.name.is_empty() {
            return Err(Status::invalid_argument("Interest name cannot be empty"));
        }
        
        // Try to use the enhanced QUIC adapter if available
        if let Some(adapter) = self.quic_adapter.as_ref() {
            match adapter.send_interest(req.clone()).await {
                Ok(response) => return Ok(Response::new(response)),
                Err(e) => {
                    tracing::warn!("QUIC adapter failed to send interest, falling back to legacy implementation: {}", e);
                    // Fall through to legacy implementation
                }
            }
        }
        
        // Get connection from legacy store
        let conn = {
            let connections = self.quic_connections.read().await;
            match connections.get(&req.connection_id) {
                Some(conn) => conn.clone(),
                None => {
                    return Err(Status::not_found(
                        format!("Connection {} not found", req.connection_id)
                    ));
                }
            }
        };
        
        // Create Interest packet
        let name = match crate::name::Name::from_uri(&req.name) {
            Ok(name) => name,
            Err(e) => {
                return Err(Status::invalid_argument(
                    format!("Invalid Interest name: {}", e)
                ));
            }
        };
        
        let mut interest = crate::ndn::Interest::new(name);
        interest.set_can_be_prefix(req.can_be_prefix);
        interest.set_must_be_fresh(req.must_be_fresh);
        interest.set_lifetime_ms(req.lifetime_ms);
        
        // Send Interest and receive Data
        let conn_lock = conn.lock().await;
        match self.transport.send_interest(&conn_lock, interest).await {
            Ok(data) => {
                let response = DataPacketResponse {
                    success: true,
                    error_message: String::new(),
                    name: data.name().to_string(),
                    content: data.content().to_vec(),
                    content_type: data.content_type() as u32,
                    freshness_period: data.freshness_period_ms(),
                    signature: data.signature().unwrap_or_default().clone(),
                    signature_type: data.signature_type().unwrap_or_default() as u32,
                    timestamp_ms: Self::current_timestamp(),
                };
                
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to send Interest: {}", e);
                tracing::error!("{}", error_message);
                
                let response = DataPacketResponse {
                    success: false,
                    error_message,
                    name: req.name,
                    content: vec![],
                    content_type: 0,
                    freshness_period: 0,
                    signature: vec![],
                    signature_type: String::new(),
                    timestamp_ms: Self::current_timestamp(),
                };
                
                Ok(Response::new(response))
            }
        }
    }
    
    // Define stream type for ReceiveData
    type ReceiveDataStream = ReceiverStream<Result<DataPacketResponse, Status>>;
    
    // Receive Data packets (server streaming)
    async fn receive_data(
        &self,
        request: Request<InterestFilter>,
    ) -> Result<Response<Self::ReceiveDataStream>, Status> {
        let req = request.into_inner();
        tracing::info!("Setting up data receiver for prefix: {}", req.prefix);
        
        // Validate input
        if req.prefix.is_empty() {
            return Err(Status::invalid_argument("Interest filter prefix cannot be empty"));
        }
        
        // Create a channel for streaming responses
        let (tx, rx) = mpsc::channel(128);
        
        // Clone necessary data for the async task
        let transport = Arc::clone(&self.transport);
        let prefix = req.prefix.clone();
        let include_subprefixes = req.include_subprefixes;
        
        // Spawn a task to handle data reception
        tokio::spawn(async move {
            match transport.register_prefix_interest(&prefix, include_subprefixes).await {
                Ok(mut data_stream) => {
                    while let Some(data_result) = data_stream.next().await {
                        match data_result {
                            Ok(data) => {
                                // Convert to protobuf response
                                let response = DataPacketResponse {
                                    success: true,
                                    error_message: String::new(),
                                    name: data.name.to_string(),
                                    content: data.content,
                                    content_type: data.content_type as u32,
                                    freshness_period: data.freshness_period_ms,
                                    signature: data.signature,
                                    signature_type: data.signature_type,
                                    timestamp_ms: SystemTime::now()
                                        .duration_since(UNIX_EPOCH)
                                        .unwrap_or_default()
                                        .as_millis() as u64,
                                };
                                
                                // Send data through channel
                                if tx.send(Ok(response)).await.is_err() {
                                    // Client likely disconnected
                                    break;
                                }
                            },
                            Err(e) => {
                                // Send error through channel
                                let error_response = DataPacketResponse {
                                    success: false,
                                    error_message: format!("Error receiving data: {}", e),
                                    name: String::new(),
                                    content: vec![],
                                    content_type: 0,
                                    freshness_period: 0,
                                    signature: vec![],
                                    signature_type: String::new(),
                                    timestamp_ms: SystemTime::now()
                                        .duration_since(UNIX_EPOCH)
                                        .unwrap_or_default()
                                        .as_millis() as u64,
                                };
                                
                                if tx.send(Ok(error_response)).await.is_err() {
                                    break;
                                }
                            }
                        }
                    }
                },
                Err(e) => {
                    // Send error and close channel
                    let _ = tx.send(Err(Status::internal(
                        format!("Failed to register interest filter: {}", e)
                    ))).await;
                }
            }
        });
        
        // Return the receiver as a stream
        Ok(Response::new(ReceiverStream::new(rx)))
    }
    
    // XDP integration methods
    
    // Configure and load the XDP program on a network interface
    async fn configure_xdp(
        &self,
        request: Request<XdpConfigRequest>,
    ) -> Result<Response<XdpConfigResponse>, Status> {
        let req = request.into_inner();
        tracing::info!("Configuring XDP program on interface: {}", req.interface_name);
        
        // Validate input
        if req.interface_name.is_empty() {
            return Err(Status::invalid_argument("Interface name cannot be empty"));
        }
        
        // Check if XDP program binary exists
        let program_path = Path::new(&req.program_path);
        if !program_path.exists() {
            return Err(Status::invalid_argument(
                format!("XDP program not found at path: {}", req.program_path)
            ));
        }
        
        // Call into the transport layer's XDP integration
        match self.transport.load_xdp_program(
            &req.interface_name,
            &req.program_path,
            req.mode.into(),
            req.map_pins.iter().map(|(k, v)| (k.clone(), v.clone())).collect(),
        ).await {
            Ok(program_id) => {
                // Store program info
                let info = XdpProgramInfo {
                    interface_name: req.interface_name.clone(),
                    program_id,
                    mode: req.mode,
                    is_loaded: true,
                    program_path: req.program_path.clone(),
                };
                
                {
                    let mut programs = self.xdp_programs.write().await;
                    programs.insert(req.interface_name.clone(), info.clone());
                }
                
                let response = XdpConfigResponse {
                    success: true,
                    error_message: String::new(),
                    program_id,
                    interface_name: req.interface_name,
                    mode: req.mode,
                    timestamp_ms: Self::current_timestamp(),
                };
                
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to load XDP program: {}", e);
                tracing::error!("{}", error_message);
                
                let response = XdpConfigResponse {
                    success: false,
                    error_message,
                    program_id: 0,
                    interface_name: req.interface_name,
                    mode: req.mode,
                    timestamp_ms: Self::current_timestamp(),
                };
                
                Ok(Response::new(response))
            }
        }
    }
    
    // Get statistics from the XDP program
    async fn get_xdp_stats(
        &self,
        request: Request<XdpStatsRequest>,
    ) -> Result<Response<XdpStatsResponse>, Status> {
        let req = request.into_inner();
        tracing::info!("Getting XDP stats for interface: {}", req.interface_name);
        
        // Validate input
        if req.interface_name.is_empty() {
            return Err(Status::invalid_argument("Interface name cannot be empty"));
        }
        
        // Check if program is loaded
        let program_id = {
            let programs = self.xdp_programs.read().await;
            match programs.get(&req.interface_name) {
                Some(info) if info.is_loaded => info.program_id,
                Some(_) => {
                    return Err(Status::failed_precondition(
                        format!("XDP program on interface {} is not loaded", req.interface_name)
                    ));
                },
                None => {
                    return Err(Status::not_found(
                        format!("No XDP program configured for interface {}", req.interface_name)
                    ));
                }
            }
        };
        
        // Get XDP statistics
        match self.transport.get_xdp_stats(program_id, &req.interface_name).await {
            Ok(stats) => {
                let response = XdpStatsResponse {
                    success: true,
                    error_message: String::new(),
                    interface_name: req.interface_name,
                    packets_received: stats.packets_received,
                    packets_dropped: stats.packets_dropped,
                    packets_redirected: stats.packets_redirected,
                    cache_hits: stats.cache_hits,
                    cache_misses: stats.cache_misses,
                    additional_stats: stats.additional_stats,
                    timestamp_ms: Self::current_timestamp(),
                };
                
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to get XDP statistics: {}", e);
                tracing::error!("{}", error_message);
                
                let response = XdpStatsResponse {
                    success: false,
                    error_message,
                    interface_name: req.interface_name,
                    packets_received: 0,
                    packets_dropped: 0,
                    packets_redirected: 0,
                    cache_hits: 0,
                    cache_misses: 0,
                    additional_stats: HashMap::new(),
                    timestamp_ms: Self::current_timestamp(),
                };
                
                Ok(Response::new(response))
            }
        }
    }
    
    // Update BPF maps used by the XDP program
    async fn update_xdp_maps(
        &self,
        request: Request<XdpMapUpdateRequest>,
    ) -> Result<Response<XdpMapUpdateResponse>, Status> {
        let req = request.into_inner();
        tracing::info!(
            "Updating XDP maps for interface: {}, map: {}", 
            req.interface_name, req.map_name
        );
        
        // Validate input
        if req.interface_name.is_empty() {
            return Err(Status::invalid_argument("Interface name cannot be empty"));
        }
        
        if req.map_name.is_empty() {
            return Err(Status::invalid_argument("Map name cannot be empty"));
        }
        
        // Check if program is loaded
        let program_id = {
            let programs = self.xdp_programs.read().await;
            match programs.get(&req.interface_name) {
                Some(info) if info.is_loaded => info.program_id,
                Some(_) => {
                    return Err(Status::failed_precondition(
                        format!("XDP program on interface {} is not loaded", req.interface_name)
                    ));
                },
                None => {
                    return Err(Status::not_found(
                        format!("No XDP program configured for interface {}", req.interface_name)
                    ));
                }
            }
        };
        
        // Update the BPF map
        match self.transport.update_xdp_map(
            program_id,
            &req.interface_name,
            &req.map_name,
            req.key,
            req.value,
        ).await {
            Ok(_) => {
                let response = XdpMapUpdateResponse {
                    success: true,
                    error_message: String::new(),
                    interface_name: req.interface_name,
                    map_name: req.map_name,
                    timestamp_ms: Self::current_timestamp(),
                };
                
                Ok(Response::new(response))
            },
            Err(e) => {
                let error_message = format!("Failed to update XDP map: {}", e);
                tracing::error!("{}", error_message);
                
                let response = XdpMapUpdateResponse {
                    success: false,
                    error_message,
                    interface_name: req.interface_name,
                    map_name: req.map_name,
                    timestamp_ms: Self::current_timestamp(),
                };
                
                Ok(Response::new(response))
            }
        }
    }
    
    // ML-based MTU Prediction methods
    
    // Predict optimal MTU size based on network statistics
    async fn predict_mtu(
        &self,
        request: Request<MtuPredictionRequest>,
    ) -> Result<Response<MtuPredictionResponse>, Status> {
        let req = request.into_inner();
        tracing::info!(
            "Predicting MTU for RTT={}ms, loss={}, throughput={}Mbps", 
            req.rtt_ms, req.packet_loss_rate, req.throughput_mbps
        );
        
        // Validate input
        if req.rtt_ms <= 0.0 {
            return Err(Status::invalid_argument("RTT must be greater than 0"));
        }
        
        if req.packet_loss_rate < 0.0 || req.packet_loss_rate > 1.0 {
            return Err(Status::invalid_argument("Packet loss rate must be between 0 and 1"));
        }
        
        if req.throughput_mbps <= 0.0 {
            return Err(Status::invalid_argument("Throughput must be greater than 0"));
        }
        
        // Use MTU predictor to predict optimal MTU
        let start_time = std::time::Instant::now();
        let prediction_result = match self.mtu_predictor.predict_mtu(
            req.rtt_ms,
            req.packet_loss_rate,
            req.throughput_mbps
        ).await {
            Ok(result) => result,
            Err(e) => {
                let error_message = format!("Failed to predict MTU: {}", e);
                tracing::error!("{}", error_message);
                
                return Err(Status::internal(error_message));
            }
        };
        
        let inference_time = start_time.elapsed().as_secs_f32() * 1000.0; // Convert to ms
        let (predicted_mtu, raw_prediction) = prediction_result;
        
        // Get current override status
        let is_override = match self.mtu_predictor.get_override().await {
            Some(_) => true,
            None => false
        };
        
        // Create response
        let response = MtuPredictionResponse {
            success: true,
            error_message: String::new(),
            predicted_mtu,
            is_override,
            confidence: 0.9, // TODO: Calculate actual confidence score
            inference_time_ms: inference_time,
            raw_prediction,
            timestamp_ms: Self::current_timestamp(),
        };
        
        Ok(Response::new(response))
    }
    
    // Override the ML model with a fixed MTU value
    async fn set_mtu_override(
        &self,
        request: Request<MtuOverrideRequest>,
    ) -> Result<Response<MtuOverrideResponse>, Status> {
        let req = request.into_inner();
        
        if req.enable_override {
            tracing::info!("Setting MTU override to {}", req.mtu_value);
            
            // Set override
            match self.mtu_predictor.set_override(Some(req.mtu_value)).await {
                Ok(_) => {
                    let response = MtuOverrideResponse {
                        success: true,
                        error_message: String::new(),
                        override_active: true,
                        override_value: req.mtu_value,
                    };
                    
                    Ok(Response::new(response))
                },
                Err(e) => {
                    let error_message = format!("Failed to set MTU override: {}", e);
                    tracing::error!("{}", error_message);
                    
                    let response = MtuOverrideResponse {
                        success: false,
                        error_message,
                        override_active: false,
                        override_value: 0,
                    };
                    
                    Ok(Response::new(response))
                }
            }
        } else {
            tracing::info!("Disabling MTU override");
            
            // Disable override
            match self.mtu_predictor.set_override(None).await {
                Ok(_) => {
                    let response = MtuOverrideResponse {
                        success: true,
                        error_message: String::new(),
                        override_active: false,
                        override_value: 0,
                    };
                    
                    Ok(Response::new(response))
                },
                Err(e) => {
                    let error_message = format!("Failed to disable MTU override: {}", e);
                    tracing::error!("{}", error_message);
                    
                    let response = MtuOverrideResponse {
                        success: false,
                        error_message,
                        override_active: true, // Assume it's still active if we failed to disable it
                        override_value: match self.mtu_predictor.get_override().await {
                            Some(val) => val,
                            None => 0,
                        },
                    };
                    
                    Ok(Response::new(response))
                }
            }
        }
    }
    
    // Get MTU prediction history
    async fn get_mtu_prediction_history(
        &self,
        request: Request<MtuHistoryRequest>,
    ) -> Result<Response<MtuHistoryResponse>, Status> {
        let req = request.into_inner();
        tracing::info!("Getting MTU prediction history (max entries: {})", req.max_entries);
        
        // Get prediction history
        let history = self.mtu_predictor.get_prediction_history(
            if req.max_entries > 0 { Some(req.max_entries) } else { None }
        ).await;
        
        // Convert history records to gRPC format
        let predictions: Vec<MtuPredictionRecord> = history.iter()
            .map(|record| MtuPredictionRecord::from(record))
            .collect();
        
        // Create response
        let response = MtuHistoryResponse {
            success: true,
            error_message: String::new(),
            predictions,
        };
        
        Ok(Response::new(response))
    }
}

// Start the gRPC server
pub async fn run_grpc_server(
    transport: Arc<UdcnTransport>,
    addr: impl Into<SocketAddr>,
    quic_adapter: Option<Arc<crate::grpc_quic_integration::GrpcQuicAdapter>>,
) -> Result<(), Box<dyn std::error::Error>> {
    let addr = addr.into();
    
    tracing::info!("Starting gRPC server on {}", addr);
    
    // Create the gRPC service with both transport and QUIC adapter
    let service = match quic_adapter {
        Some(adapter) => {
            tracing::info!("Using enhanced QUIC transport integration");
            UdcnControlService::new_with_quic(transport, adapter)
        },
        None => {
            tracing::info!("Using standard transport without QUIC enhancement");
            UdcnControlService::new(transport)
        }
    };
    
    Server::builder()
        .add_service(UdcnControlServer::new(service))
        .serve(addr)
        .await?;
    
    Ok(())
}
