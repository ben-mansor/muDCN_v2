//
// uDCN Error Types
//
// This module defines the error types used throughout the uDCN transport layer.
//

use thiserror::Error;
use std::io;
use std::fmt;
use std::net::AddrParseError;
use std::time::Duration;
use bytes::Bytes;

/// Result type for the μDCN transport
pub type Result<T> = std::result::Result<T, Error>;

/// Comprehensive error types for the μDCN transport layer
#[derive(Error, Debug)]
pub enum Error {
    /// I/O error
    #[error("I/O error: {0}")]
    Io(#[from] io::Error),
    
    /// QUIC error
    #[error("QUIC error: {0}")]
    Quic(#[from] quinn::ConnectionError),
    
    /// TLS error
    #[error("TLS error: {0}")]
    Tls(#[from] rustls::Error),
    
    /// Address parsing error
    #[error("Address parsing error: {0}")]
    AddrParseError(#[from] AddrParseError),
    
    /// Custom address parse error with message
    #[error("Address parse error: {0}")]
    AddrParseErrorWithMsg(String),
    
    /// Connection error
    #[error("Connection error: {0}")]
    ConnectionError(String),
    
    /// Name parsing error
    #[error("Name parsing error: {0}")]
    NameParsing(String),
    
    /// TLV parsing error
    #[error("TLV parsing error: {0}")]
    TlvParsing(String),
    
    /// No connections available
    #[error("No connections available")]
    NoConnections,
    
    /// Invalid address
    #[error("Invalid address: {0}")]
    InvalidAddress(String),
    
    /// Configuration error
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    
    /// Invalid MTU value
    #[error("Invalid MTU value: {0}")]
    InvalidMtu(usize),
    
    /// Timeout error
    #[error("Timeout error: {0}")]
    Timeout(String),
    
    /// Content store error
    #[error("Content store error: {0}")]
    ContentStore(String),
    
    /// Signature verification error
    #[error("Signature verification failed: {0}")]
    SignatureVerification(String),
    
    /// Fragmentation error
    #[error("Fragmentation error: {0}")]
    Fragmentation(String),
    
    /// ML model error
    #[error("ML model error: {0}")]
    MlModel(String),
    
    /// XDP error
    #[error("XDP error: {0}")]
    XdpError(String),
    
    /// Generic error
    #[error("{0}")]
    Other(String),
    
    /// Invalid state error
    #[error("Invalid state: {0}")]
    InvalidState(String),
    
    /// Invalid argument error
    #[error("Invalid argument: {0}")]
    InvalidArgument(String),
    
    /// Not found error
    #[error("{0} not found")]
    NotFound(String),
    
    /// Protocol error
    #[error("Protocol error: {0}")]
    ProtocolError(String),
    
    /// IO Error
    #[error("IO error: {0}")]
    IoError(String),
    
    /// Connection Error
    #[error("Connection error: {0}")]
    ConnectionError(String),
    
    /// Reassembly error
    #[error("Reassembly error: {0}")]
    ReassemblyError(String),
    
    /// Parsing error
    #[error("Parsing error: {0}")]
    ParsingError(String),
    
    /// Operation error
    #[error("Operation error: {0}")]
    OperationError(String),
}

// Display implementation is handled by the thiserror derive macro
// Removed duplicate implementation// std::error::Error trait is implemented by thiserror

/// Helper to create timeout error
pub fn timeout<T>(duration: Duration, error_context: &str) -> Result<T> {
    // Create descriptive timeout error message
    Err(Error::Timeout(format!("Operation timed out after {} ms", duration.as_millis())))
}

// Convert from Quinn connection creation error
impl From<quinn::ConnectError> for Error {
    fn from(err: quinn::ConnectError) -> Self {
        Error::Quic(quinn::ConnectionError::ApplicationClosed(quinn::ApplicationClose {
            error_code: 0u32.into(),
            reason: bytes::Bytes::new(),
        }))
    }
}

// Note: The From<quinn::ConnectionError> implementation is automatically
// generated by the #[from] attribute in the Error enum

// Convert from string
impl From<String> for Error {
    fn from(s: String) -> Self {
        Error::Other(s)
    }
}

// Convert from static string
impl From<&'static str> for Error {
    fn from(s: &'static str) -> Self {
        Error::Other(s.to_string())
    }
}
