#!/usr/bin/env python3
"""
μDCN Transport Layer gRPC Client

This module provides a client for communicating with the Rust transport layer
via gRPC. It handles connection management, retries, and provides a high-level
API for controlling the transport layer.
"""

import logging
import time
from typing import Dict, List, Optional, Any, Tuple, Union
import grpc

# Import the generated proto modules (to be generated by generate_protos.py)
from udcn_control.proto import udcn_pb2
from udcn_control.proto import udcn_pb2_grpc

# Configure logging
logger = logging.getLogger(__name__)

class TransportClientError(Exception):
    """Exception raised for errors in the TransportClient."""
    pass

class TransportClient:
    """
    Client for communicating with the μDCN transport layer via gRPC.
    
    This class provides a high-level API for controlling the transport layer,
    including methods for updating MTU, registering prefixes, and monitoring
    performance metrics.
    """
    
    def __init__(
        self, 
        host: str = "localhost", 
        port: int = 9091, 
        timeout: int = 10,
        max_retries: int = 3,
        retry_delay: float = 1.0
    ):
        """
        Initialize the Transport Client.
        
        Args:
            host (str): The hostname or IP address of the transport layer gRPC server.
            port (int): The port number of the transport layer gRPC server.
            timeout (int): The timeout in seconds for gRPC calls.
            max_retries (int): Maximum number of retries for failed gRPC calls.
            retry_delay (float): Initial delay between retries in seconds (will be exponentially backed off).
        """
        self.host = host
        self.port = port
        self.address = f"{host}:{port}"
        self.timeout = timeout
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        
        # Initialize as None, will be created when needed
        self._channel = None
        self._stub = None
        
    def __enter__(self):
        """Context manager entry."""
        self.connect()
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.close()
        
    def connect(self) -> None:
        """Establish the gRPC channel and create the stub."""
        if self._channel is None or self._channel.get_state() == grpc.ChannelConnectivity.SHUTDOWN:
            logger.info(f"Connecting to transport layer at {self.address}")
            # Create an insecure channel (for development/testing)
            # In production, use secure_channel with proper credentials
            self._channel = grpc.insecure_channel(self.address)
            self._stub = udcn_pb2_grpc.UdcnControlStub(self._channel)
    
    def close(self) -> None:
        """Close the gRPC channel."""
        if self._channel is not None:
            logger.info("Closing transport client connection")
            self._channel.close()
            self._channel = None
            self._stub = None
    
    def _call_with_retry(self, method_name: str, request, *args, **kwargs):
        """
        Call a gRPC method with automatic retries.
        
        Args:
            method_name (str): The name of the method to call on the stub.
            request: The gRPC request object.
            *args, **kwargs: Additional arguments to pass to the method.
            
        Returns:
            The response from the gRPC method.
            
        Raises:
            TransportClientError: If all retries fail.
        """
        self.connect()  # Ensure we're connected
        
        method = getattr(self._stub, method_name)
        metadata = kwargs.pop("metadata", ())
        timeout = kwargs.pop("timeout", self.timeout)
        
        retry_count = 0
        last_exception = None
        
        while retry_count <= self.max_retries:
            try:
                return method(request, metadata=metadata, timeout=timeout, *args, **kwargs)
            except grpc.RpcError as e:
                last_exception = e
                retry_count += 1
                
                if retry_count > self.max_retries:
                    break
                
                # Calculate backoff delay
                delay = self.retry_delay * (2 ** (retry_count - 1))
                logger.warning(
                    f"gRPC call {method_name} failed (attempt {retry_count}/{self.max_retries}): {e}. "
                    f"Retrying in {delay:.2f} seconds..."
                )
                time.sleep(delay)
        
        # If we get here, all retries failed
        error_msg = f"Failed to call {method_name} after {self.max_retries} retries"
        if last_exception:
            error_msg += f": {last_exception}"
        
        logger.error(error_msg)
        raise TransportClientError(error_msg)
    
    def update_mtu(
        self, 
        mtu: int, 
        interface_name: str = "", 
        confidence: float = 1.0,
        metadata: Dict[str, str] = None
    ) -> Tuple[bool, str, int, int]:
        """
        Update the MTU of the transport layer.
        
        Args:
            mtu (int): The new MTU value.
            interface_name (str, optional): The network interface to update.
            confidence (float, optional): The confidence level of the MTU prediction (0.0-1.0).
            metadata (Dict[str, str], optional): Additional metadata for the request.
            
        Returns:
            Tuple[bool, str, int, int]: (success, error_message, previous_mtu, current_mtu)
        """
        request = udcn_pb2.MtuRequest(
            mtu=mtu,
            interface_name=interface_name,
            confidence=confidence,
            metadata=metadata or {}
        )
        
        response = self._call_with_retry("UpdateMtu", request)
        
        return (
            response.success,
            response.error_message,
            response.previous_mtu,
            response.current_mtu
        )
    
    def register_prefix(
        self, 
        prefix: str, 
        is_producer: bool = True, 
        priority: int = 0,
        flags: Dict[str, str] = None
    ) -> Tuple[bool, str, int]:
        """
        Register a prefix with the transport layer.
        
        Args:
            prefix (str): The NDN name prefix to register.
            is_producer (bool): If True, register as a producer; otherwise as a forwarder.
            priority (int): Priority of the prefix (for forwarding).
            flags (Dict[str, str], optional): Additional flags for the registration.
            
        Returns:
            Tuple[bool, str, int]: (success, error_message, registration_id)
        """
        prefix_type = udcn_pb2.PrefixRegistrationRequest.PrefixType.PRODUCER if is_producer else \
                     udcn_pb2.PrefixRegistrationRequest.PrefixType.FORWARDER
        
        request = udcn_pb2.PrefixRegistrationRequest(
            prefix=prefix,
            type=prefix_type,
            priority=priority,
            flags=flags or {}
        )
        
        response = self._call_with_retry("RegisterPrefix", request)
        
        return (
            response.success,
            response.error_message,
            response.registration_id
        )
    
    def unregister_prefix(self, registration_id: int, prefix: str = "") -> Tuple[bool, str]:
        """
        Unregister a previously registered prefix.
        
        Args:
            registration_id (int): The ID returned when the prefix was registered.
            prefix (str, optional): The prefix string, for debugging/logging purposes.
            
        Returns:
            Tuple[bool, str]: (success, error_message)
        """
        request = udcn_pb2.PrefixUnregistrationRequest(
            registration_id=registration_id,
            prefix=prefix
        )
        
        response = self._call_with_retry("UnregisterPrefix", request)
        
        return (
            response.success,
            response.error_message
        )
    
    def get_metrics(
        self, 
        metric_names: List[str] = None, 
        since_timestamp: int = 0
    ) -> Dict[str, Any]:
        """
        Get metrics from the transport layer.
        
        Args:
            metric_names (List[str], optional): Specific metrics to retrieve. If None, get all.
            since_timestamp (int, optional): Only get metrics since this timestamp.
            
        Returns:
            Dict[str, Any]: Dictionary of metric names to values.
        """
        request = udcn_pb2.MetricsRequest(
            metric_names=metric_names or [],
            since_timestamp=since_timestamp
        )
        
        response = self._call_with_retry("GetMetrics", request)
        
        if not response.success:
            raise TransportClientError(f"Failed to get metrics: {response.error_message}")
        
        # Process the metrics into a more Pythonic format
        result = {}
        for name, metric_value in response.metrics.items():
            if metric_value.HasField("counter_value"):
                result[name] = metric_value.counter_value
            elif metric_value.HasField("gauge_value"):
                result[name] = metric_value.gauge_value
            elif metric_value.HasField("histogram_value"):
                hist = metric_value.histogram_value
                result[name] = {
                    "buckets": list(hist.buckets),
                    "counts": list(hist.counts),
                    "sum": hist.sum,
                    "count": hist.count
                }
        
        return result
    
    def get_network_interfaces(self, include_stats: bool = True) -> List[Dict[str, Any]]:
        """
        Get information about network interfaces from the transport layer.
        
        Args:
            include_stats (bool): Whether to include statistics (rx/tx bytes, packets, etc.).
            
        Returns:
            List[Dict[str, Any]]: List of dictionaries with interface information.
        """
        request = udcn_pb2.NetworkInterfacesRequest(
            include_stats=include_stats
        )
        
        response = self._call_with_retry("GetNetworkInterfaces", request)
        
        if not response.success:
            raise TransportClientError(
                f"Failed to get network interfaces: {response.error_message}"
            )
        
        # Convert to list of dictionaries
        interfaces = []
        for iface in response.interfaces:
            interface_dict = {
                "name": iface.name,
                "mac_address": iface.mac_address,
                "ip_addresses": list(iface.ip_addresses),
                "mtu": iface.mtu,
                "is_up": iface.is_up
            }
            
            if include_stats:
                interface_dict.update({
                    "rx_bytes": iface.rx_bytes,
                    "tx_bytes": iface.tx_bytes,
                    "rx_packets": iface.rx_packets,
                    "tx_packets": iface.tx_packets,
                    "rx_errors": iface.rx_errors,
                    "tx_errors": iface.tx_errors,
                    "rx_dropped": iface.rx_dropped,
                    "tx_dropped": iface.tx_dropped
                })
            
            interfaces.append(interface_dict)
        
        return interfaces
    
    def control_transport(self, action: str, parameters: Dict[str, str] = None) -> Tuple[bool, str, str]:
        """
        Control the transport layer state (start, stop, restart, pause, resume).
        
        Args:
            action (str): The action to perform. One of: "start", "stop", "restart", "pause", "resume".
            parameters (Dict[str, str], optional): Additional parameters for the action.
            
        Returns:
            Tuple[bool, str, str]: (success, error_message, current_state)
        """
        # Map string action to enum value
        action_map = {
            "start": udcn_pb2.TransportControlRequest.ControlAction.START,
            "stop": udcn_pb2.TransportControlRequest.ControlAction.STOP,
            "restart": udcn_pb2.TransportControlRequest.ControlAction.RESTART,
            "pause": udcn_pb2.TransportControlRequest.ControlAction.PAUSE,
            "resume": udcn_pb2.TransportControlRequest.ControlAction.RESUME
        }
        
        if action.lower() not in action_map:
            raise ValueError(
                f"Invalid action: {action}. Must be one of: {', '.join(action_map.keys())}"
            )
        
        request = udcn_pb2.TransportControlRequest(
            action=action_map[action.lower()],
            parameters=parameters or {}
        )
        
        response = self._call_with_retry("ControlTransport", request)
        
        # Map enum state to string
        state_map = {
            0: "running",
            1: "stopped",
            2: "paused",
            3: "error",
            4: "starting",
            5: "stopping"
        }
        
        current_state = state_map.get(response.current_state, "unknown")
        
        return (
            response.success,
            response.error_message,
            current_state
        )
    
    def stream_metrics(
        self, 
        metric_names: List[str] = None, 
        interval_ms: int = 1000, 
        max_samples: int = 0
    ) -> grpc.RpcContext:
        """
        Stream metrics from the transport layer.
        
        Args:
            metric_names (List[str], optional): Specific metrics to stream. If None, stream all.
            interval_ms (int): Interval between metric samples in milliseconds.
            max_samples (int): Maximum number of samples to retrieve (0 for unlimited).
            
        Returns:
            grpc.RpcContext: A streaming context that yields metric data.
            
        Example:
            ```
            for metrics_data in client.stream_metrics(["cache_hits", "cache_misses"], interval_ms=500):
                print(f"Timestamp: {metrics_data.timestamp}")
                for name, value in metrics_data.metrics.items():
                    print(f"  {name}: {value}")
            ```
        """
        self.connect()  # Ensure we're connected
        
        request = udcn_pb2.StreamMetricsRequest(
            metric_names=metric_names or [],
            interval_ms=interval_ms,
            max_samples=max_samples
        )
        
        # This is a streaming call, so we don't use _call_with_retry
        return self._stub.StreamMetrics(request, timeout=None)
    
    def configure_transport(
        self, 
        cache_capacity: Optional[int] = None,
        idle_timeout: Optional[int] = None,
        enable_metrics: Optional[bool] = None,
        metrics_port: Optional[int] = None,
        bind_address: Optional[str] = None,
        advanced_config: Dict[str, str] = None
    ) -> Tuple[bool, str, Dict[str, Any]]:
        """
        Configure the transport layer parameters.
        
        Args:
            cache_capacity (int, optional): Size of the content store.
            idle_timeout (int, optional): QUIC idle timeout in seconds.
            enable_metrics (bool, optional): Whether to enable metrics collection.
            metrics_port (int, optional): Port for the metrics HTTP server.
            bind_address (str, optional): Address to bind the transport layer to.
            advanced_config (Dict[str, str], optional): Additional configuration parameters.
            
        Returns:
            Tuple[bool, str, Dict[str, Any]]: (success, error_message, current_config)
        """
        # Only include parameters that are explicitly provided
        request_kwargs = {}
        if cache_capacity is not None:
            request_kwargs["cache_capacity"] = cache_capacity
        if idle_timeout is not None:
            request_kwargs["idle_timeout"] = idle_timeout
        if enable_metrics is not None:
            request_kwargs["enable_metrics"] = enable_metrics
        if metrics_port is not None:
            request_kwargs["metrics_port"] = metrics_port
        if bind_address is not None:
            request_kwargs["bind_address"] = bind_address
        if advanced_config is not None:
            request_kwargs["advanced_config"] = advanced_config
        
        request = udcn_pb2.TransportConfigRequest(**request_kwargs)
        
        response = self._call_with_retry("ConfigureTransport", request)
        
        if not response.success:
            return (False, response.error_message, {})
        
        # Convert config to dictionary
        config = {}
        if response.HasField("current_config"):
            cfg = response.current_config
            config = {
                "mtu": cfg.mtu,
                "cache_capacity": cfg.cache_capacity,
                "idle_timeout": cfg.idle_timeout,
                "enable_metrics": cfg.enable_metrics,
                "metrics_port": cfg.metrics_port,
                "bind_address": cfg.bind_address,
                "advanced_config": dict(cfg.advanced_config)
            }
        
        return (
            response.success,
            response.error_message,
            config
        )
    
    def get_transport_state(self, include_detailed_stats: bool = False) -> Dict[str, Any]:
        """
        Get the current state of the transport layer.
        
        Args:
            include_detailed_stats (bool): Whether to include detailed statistics.
            
        Returns:
            Dict[str, Any]: Dictionary with state and statistics.
        """
        request = udcn_pb2.TransportStateRequest(
            include_detailed_stats=include_detailed_stats
        )
        
        response = self._call_with_retry("GetTransportState", request)
        
        if not response.success:
            raise TransportClientError(
                f"Failed to get transport state: {response.error_message}"
            )
        
        # Map enum state to string
        state_map = {
            0: "running",
            1: "stopped",
            2: "paused",
            3: "error",
            4: "starting",
            5: "stopping"
        }
        
        state = state_map.get(response.state, "unknown")
        
        result = {
            "state": state,
            "uptime_seconds": response.uptime_seconds,
            "interests_processed": response.interests_processed,
            "data_packets_sent": response.data_packets_sent,
            "cache_hits": response.cache_hits,
            "cache_misses": response.cache_misses,
            "cache_hit_ratio": response.cache_hit_ratio
        }
        
        if include_detailed_stats:
            result["detailed_stats"] = dict(response.detailed_stats)
        
        return result
